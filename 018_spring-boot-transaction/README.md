# spring-boot-transaction
Database mimarisinde transaction bilgisayar mimarisi ile kıyaslandığında bir işlem grubunu(process'ler) temsil ederken, genellikle bir grup SQL komutunun bütünlüğünü sağlamak için kullanılır. Transaction, bir veya daha fazla SQL komutunun bir arada gerçekleştirilmesini ve bu komutların tümünün başarıyla tamamlanıp tamamlanmadığını kontrol eder. Eğer bir işlem sırasında hata olursa, tüm SQL komutları geri alınır (rollback) ve veri tutarlılığı korunur. Bu açıdan bakıldığında, transaction’lar bir süreç (process) gibi düşünülebilir, çünkü belirli bir görev (veri manipülasyonu) gerçekleştirmek için bir araya getirilen bir dizi komutu temsil eder. Kısacası, transaction, bir grup SQL komutunun bir bütün olarak yönetilmesini sağlar ve bilgisayar mimarisi bağlamında bir süreçle benzerlik gösterir.

Transaction, yani işlem, veritabanında bir dizi işlemin bütünlüğünü sağlamak için kullanılan bir yapıdır. Bir işlem, birkaç alt işlemi içerir ve bu işlemlerden herhangi biri başarısız olursa, tüm işlemin geri alınmasını yani "rollback" yapılmasını sağlar. Bu sayede veritabanındaki veriler tutarlı kalır. Örneğin, bir kullanıcı bir ürün satın alırken, ödeme işlemi ve stok güncelleme gibi iki önemli adım gerçekleşir. Eğer ödeme alındı fakat stok güncellenmezse, bu tutarsızlık oluşturur. İşte burada transaction devreye girer; her iki işlem de başarılı olursa işlem tamamlanır, aksi takdirde hiçbir işlem gerçekleşmez. Spring Boot ile transaction yönetimi yaparak bu süreçleri kolay ve güvenilir bir şekilde yönetebiliyorum. Bu, uygulamamın veri bütünlüğünü koruyarak kullanıcı deneyimini iyileştirmeme yardımcı oluyor.

@Transactional anotasyonu, Spring uygulamalarında transaction yönetimini kolaylaştırmak için kullanılır. Bu anotasyonu bir yöntem veya sınıf üzerinde kullandığınızda, o yöntemdeki tüm işlemlerin bir transaction içinde gerçekleştirilmesini sağlar. Eğer yöntem içindeki herhangi bir işlem başarısız olursa, tüm işlemler geri alınır ve veritabanı tutarlılığı korunur. Böylece, bir dizi veritabanı işlemini güvenli ve tutarlı bir şekilde yönetmek mümkün hale gelir.

@Transactional(propagation = Propagation.REQUIRES_NEW) bu dipnot bir transaction hali hazırda çalışıyorsa ona dahil olmadan yeni bir transaction başlatıyor. İki transaction'da bir birini etkilemeden ayrı ayrı izole şekilde çalışıyor. Eğer birinde hata olursa sadece hata oluşan transaction rollback yapılıyor. Birbirlerini etkilemiyorlar böylece.